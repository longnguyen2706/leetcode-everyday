# Description 
N - Queens
https://leetcode.com/problems/n-queens/description/


# Notes
- Time taken: 42 mins 
    - Got stuck at res return all empty arrays. Issue is we need to add copy of path arr instead of path arr (since path arr will got remove element and becomee empty later on)
    - Current time complexity: n^n 
- It could be done better if we use set to keep track of ard selected col (so that time complexity become n(n-1)...1 = n!). We could even keep diag_left and diag_right set that generated by prev row and check against the current row
- Also, we could update on the 2D board right away instead of converting the result later
- There is a tip for checking the diag 
```
In this problem, whenever a location (x, y) is occupied, any other locations (p, q ) where p + q == x + y or p - q == x - y would be invalid. We can use this information to keep track of the indicators (xy_dif and xy_sum ) of the invalid positions and then call DFS recursively with valid positions only.

```

# Solutions
```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        # better to use the cell cord during operation 

        def is_same_col(cord1, cord2):
            return cord1[1] == cord2[1]

        def is_same_left_diag(cord1, cord2):
            return cord1[0] -cord2[0]== cord1[1] - cord2[1]
        
        def is_same_right_diag(cord1, cord2):
            return cord1[0] -cord2[0] == cord2[1] - cord1[1]
        
        def is_valid(cord1, cord2):
            return not is_same_col(cord1, cord2) and not is_same_left_diag(cord1, cord2) and not is_same_right_diag(cord1, cord2)

        def convert_result(cords, n):
            r = []
            for cord in cords:
                s = "" 
                for i in range (0, n): 
                    if i == cord[1]:
                        s += "Q"
                    else: 
                        s+="."
                r.append(s)
            return r 

        def backtrack(r, n, path, res):
            if r == n: 
                res.append(path.copy()) # or res.append(path[:])
                return 
            # print (r, n, path)
            # print ("res: ", res)
            
            for i in range (n):
                valid = True
                for cord in path: 
                    if not is_valid((r, i), cord):
                        valid = False
                        break
                if valid: 
                    path.append((r, i))
                    backtrack(r+1, n, path, res)
                    path.remove((r, i))

        cord_arr= []
        backtrack(0, n, [], cord_arr)

        res = []
        for cords in cord_arr: 
            res.append(convert_result(cords, n))

        # print (res)
        return res
```

Optimal solution 
```python
class Solution:
    def solveNQueens(self, n):
        # Making use of a helper function to get the
        # solutions in the correct output format
        def create_board(state):
            board = []
            for row in state:
                board.append("".join(row))
            return board
        
        def backtrack(row, diagonals, anti_diagonals, cols, state):
            # Base case - N queens have been placed
            if row == n:
                ans.append(create_board(state))
                return

            for col in range(n):
                curr_diagonal = row - col
                curr_anti_diagonal = row + col
                # If the queen is not placeable
                if (col in cols 
                      or curr_diagonal in diagonals 
                      or curr_anti_diagonal in anti_diagonals):
                    continue

                # "Add" the queen to the board
                cols.add(col)
                diagonals.add(curr_diagonal)
                anti_diagonals.add(curr_anti_diagonal)
                state[row][col] = "Q"

                # Move on to the next row with the updated board state
                backtrack(row + 1, diagonals, anti_diagonals, cols, state)

                # "Remove" the queen from the board since we have already
                # explored all valid paths using the above function call
                cols.remove(col)
                diagonals.remove(curr_diagonal)
                anti_diagonals.remove(curr_anti_diagonal)
                state[row][col] = "."

        ans = []
        empty_board = [["."] * n for _ in range(n)]
        backtrack(0, set(), set(), set(), empty_board)
        return ans 
```

Other solution 
```python
def solveNQueens(self, n):
    res = []
    self.dfs([-1]*n, 0, [], res)
    return res
 
# nums is a one-dimension array, like [1, 3, 0, 2] means
# first queen is placed in column 1, second queen is placed
# in column 3, etc.
def dfs(self, nums, index, path, res):
    if index == len(nums):
        res.append(path)
        return  # backtracking
    for i in xrange(len(nums)):
        nums[index] = i
        if self.valid(nums, index):  # pruning
            tmp = "."*len(nums)
            self.dfs(nums, index+1, path+[tmp[:i]+"Q"+tmp[i+1:]], res)

# check whether nth queen can be placed in that column
def valid(self, nums, n):
    for i in xrange(n):
        if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]:
            return False
    return True 
```